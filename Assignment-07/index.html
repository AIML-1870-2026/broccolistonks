<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mitosis - Turing Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0812;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .control-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(15, 10, 25, 0.92);
            border: 1px solid rgba(180, 100, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .control-panel h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #b388ff, #ff80ab);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-panel .subtitle {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 15px;
        }

        .section {
            margin-bottom: 18px;
        }

        .section-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #b388ff;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(180, 100, 255, 0.2);
            padding-bottom: 5px;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }

        .slider-label span:last-child {
            color: #b388ff;
            font-family: 'Courier New', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(180, 100, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #b388ff, #ff80ab);
            border-radius: 50%;
            cursor: pointer;
        }

        .phase-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .phase-btn {
            background: rgba(180, 100, 255, 0.1);
            border: 1px solid rgba(180, 100, 255, 0.3);
            color: #e0e0e0;
            padding: 10px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            text-align: center;
        }

        .phase-btn:hover {
            background: rgba(180, 100, 255, 0.2);
            border-color: rgba(180, 100, 255, 0.5);
        }

        .phase-btn.active {
            background: rgba(180, 100, 255, 0.3);
            border-color: #b388ff;
        }

        .phase-btn .phase-name {
            font-weight: 600;
            display: block;
            margin-bottom: 2px;
        }

        .phase-btn .phase-desc {
            font-size: 0.65rem;
            color: #999;
        }

        .viz-toggle {
            display: flex;
            gap: 8px;
        }

        .viz-btn {
            flex: 1;
            background: rgba(180, 100, 255, 0.1);
            border: 1px solid rgba(180, 100, 255, 0.3);
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .viz-btn.active {
            background: linear-gradient(135deg, rgba(179, 136, 255, 0.3), rgba(255, 128, 171, 0.3));
            border-color: #b388ff;
        }

        .action-btn {
            width: 100%;
            background: linear-gradient(135deg, #b388ff, #ff80ab);
            border: none;
            color: #0a0812;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 8px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(179, 136, 255, 0.3);
        }

        .action-btn.secondary {
            background: rgba(180, 100, 255, 0.2);
            color: #e0e0e0;
        }

        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(15, 10, 25, 0.85);
            border: 1px solid rgba(180, 100, 255, 0.2);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
            color: #b388ff;
            z-index: 100;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 10, 25, 0.85);
            border: 1px solid rgba(180, 100, 255, 0.2);
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 0.75rem;
            color: #888;
            z-index: 100;
        }

        .instructions strong {
            color: #b388ff;
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 10, 25, 0.95);
            border: 1px solid rgba(180, 100, 255, 0.3);
            border-radius: 12px;
            padding: 15px 25px;
            max-width: 500px;
            width: calc(100% - 340px);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
        }

        .info-panel.active {
            display: block;
        }

        .info-panel h3 {
            color: #b388ff;
            font-size: 1rem;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
        }

        .cell-count {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(180, 100, 255, 0.1);
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .cell-count span {
            color: #ff80ab;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .control-panel {
                width: calc(100% - 40px);
                max-height: 45vh;
            }

            .stats, .instructions {
                display: none;
            }

            .info-panel {
                width: calc(100% - 40px);
                bottom: auto;
                top: auto;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="control-panel">
        <h1>Mitosis</h1>
        <p class="subtitle">Cellular Division Patterns</p>

        <div class="section">
            <div class="section-title">Cell Cycle Phases</div>
            <div class="phase-grid">
                <button class="phase-btn active" data-phase="interphase">
                    <span class="phase-name">Interphase</span>
                    <span class="phase-desc">Growth & DNA replication</span>
                </button>
                <button class="phase-btn" data-phase="prophase">
                    <span class="phase-name">Prophase</span>
                    <span class="phase-desc">Chromatin condenses</span>
                </button>
                <button class="phase-btn" data-phase="metaphase">
                    <span class="phase-name">Metaphase</span>
                    <span class="phase-desc">Chromosomes align</span>
                </button>
                <button class="phase-btn" data-phase="anaphase">
                    <span class="phase-name">Anaphase</span>
                    <span class="phase-desc">Separation begins</span>
                </button>
                <button class="phase-btn" data-phase="telophase">
                    <span class="phase-name">Telophase</span>
                    <span class="phase-desc">Nuclear division</span>
                </button>
                <button class="phase-btn" data-phase="cytokinesis">
                    <span class="phase-name">Cytokinesis</span>
                    <span class="phase-desc">Cell splits in two</span>
                </button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Reaction Parameters</div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Feed Rate (f)</span>
                    <span id="feedValue">0.0367</span>
                </div>
                <input type="range" id="feedRate" min="0.01" max="0.08" step="0.0001" value="0.0367">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Kill Rate (k)</span>
                    <span id="killValue">0.0649</span>
                </div>
                <input type="range" id="killRate" min="0.04" max="0.07" step="0.0001" value="0.0649">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Diffusion A</span>
                    <span id="daValue">1.00</span>
                </div>
                <input type="range" id="diffusionA" min="0.5" max="1.5" step="0.01" value="1.0">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Diffusion B</span>
                    <span id="dbValue">0.50</span>
                </div>
                <input type="range" id="diffusionB" min="0.2" max="0.8" step="0.01" value="0.5">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Visualization</div>
            <div class="viz-toggle">
                <button class="viz-btn active" data-viz="cellular">Cellular</button>
                <button class="viz-btn" data-viz="membrane">Membrane</button>
                <button class="viz-btn" data-viz="xray">X-Ray</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Brush Size</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Nucleus Size</span>
                    <span id="brushValue">15</span>
                </div>
                <input type="range" id="brushSize" min="5" max="40" step="1" value="15">
            </div>
        </div>

        <button class="action-btn" id="resetBtn">New Cell Culture</button>
        <button class="action-btn secondary" id="infoBtn">About Mitosis</button>
    </div>

    <div class="stats" id="stats">
        FPS: <span id="fps">60</span> | Resolution: <span id="resolution">512x512</span>
    </div>

    <div class="instructions">
        <strong>Click & Drag</strong> to seed new cells<br>
        <strong>Scroll</strong> to adjust nucleus size
    </div>

    <div class="info-panel" id="infoPanel">
        <h3>Turing Patterns & Cell Division</h3>
        <p>
            Alan Turing's 1952 reaction-diffusion model explains how biological patterns emerge.
            In this simulation, two chemicals (activator A and inhibitor B) interact and diffuse
            at different rates, spontaneously forming patterns that mirror cell division.
            The "mitosis" parameters create blob-like structures that split and multiplyâ€”
            just like real cells undergoing division.
        </p>
        <div class="cell-count">
            Current phase: <span id="currentPhase">Interphase</span>
        </div>
    </div>

    <script>
        // Cell cycle phases with different parameters
        const phases = {
            interphase: {
                name: "Interphase",
                feed: 0.0367,
                kill: 0.0649,
                da: 1.0,
                db: 0.5,
                desc: "Cells grow and replicate DNA. Patterns form slowly and remain stable."
            },
            prophase: {
                name: "Prophase",
                feed: 0.0380,
                kill: 0.0640,
                da: 1.0,
                db: 0.5,
                desc: "Chromatin begins to condense. Patterns become more defined."
            },
            metaphase: {
                name: "Metaphase",
                feed: 0.0390,
                kill: 0.0630,
                da: 1.0,
                db: 0.5,
                desc: "Chromosomes align at the cell equator. Patterns stabilize."
            },
            anaphase: {
                name: "Anaphase",
                feed: 0.0350,
                kill: 0.0655,
                da: 1.0,
                db: 0.5,
                desc: "Sister chromatids separate. Patterns begin to split."
            },
            telophase: {
                name: "Telophase",
                feed: 0.0340,
                kill: 0.0660,
                da: 1.0,
                db: 0.5,
                desc: "Nuclear membranes reform. New daughter patterns emerge."
            },
            cytokinesis: {
                name: "Cytokinesis",
                feed: 0.0320,
                kill: 0.0665,
                da: 1.0,
                db: 0.5,
                desc: "The cell divides in two. Patterns multiply and separate."
            }
        };

        // WebGL Setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL is not supported in your browser');
        }

        // Simulation parameters
        let params = {
            feed: 0.0367,
            kill: 0.0649,
            da: 1.0,
            db: 0.5,
            brushSize: 15,
            vizMode: 'cellular',
            currentPhase: 'interphase'
        };

        let simWidth = 512;
        let simHeight = 512;
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Simulation fragment shader (Gray-Scott model)
        const simulationShaderSource = `
            precision highp float;

            uniform sampler2D u_texture;
            uniform vec2 u_resolution;
            uniform float u_feed;
            uniform float u_kill;
            uniform float u_da;
            uniform float u_db;
            uniform float u_dt;
            uniform vec2 u_mouse;
            uniform float u_brushSize;
            uniform float u_mouseDown;

            varying vec2 v_texCoord;

            void main() {
                vec2 texel = 1.0 / u_resolution;

                vec4 center = texture2D(u_texture, v_texCoord);
                vec4 left = texture2D(u_texture, v_texCoord + vec2(-texel.x, 0.0));
                vec4 right = texture2D(u_texture, v_texCoord + vec2(texel.x, 0.0));
                vec4 up = texture2D(u_texture, v_texCoord + vec2(0.0, texel.y));
                vec4 down = texture2D(u_texture, v_texCoord + vec2(0.0, -texel.y));

                vec4 ul = texture2D(u_texture, v_texCoord + vec2(-texel.x, texel.y));
                vec4 ur = texture2D(u_texture, v_texCoord + vec2(texel.x, texel.y));
                vec4 dl = texture2D(u_texture, v_texCoord + vec2(-texel.x, -texel.y));
                vec4 dr = texture2D(u_texture, v_texCoord + vec2(texel.x, -texel.y));

                vec4 laplacian = (left + right + up + down) * 0.2
                               + (ul + ur + dl + dr) * 0.05
                               - center;

                float a = center.r;
                float b = center.g;

                float reaction = a * b * b;
                float da = u_da * laplacian.r - reaction + u_feed * (1.0 - a);
                float db = u_db * laplacian.g + reaction - (u_kill + u_feed) * b;

                float newA = a + da * u_dt;
                float newB = b + db * u_dt;

                if (u_mouseDown > 0.5) {
                    float dist = length(v_texCoord - u_mouse);
                    float brushRadius = u_brushSize / u_resolution.x;
                    if (dist < brushRadius) {
                        float strength = 1.0 - smoothstep(0.0, brushRadius, dist);
                        newB = mix(newB, 1.0, strength * 0.6);
                    }
                }

                gl_FragColor = vec4(clamp(newA, 0.0, 1.0), clamp(newB, 0.0, 1.0), 0.0, 1.0);
            }
        `;

        // Display fragment shader with cellular visualization
        const displayShaderSource = `
            precision highp float;

            uniform sampler2D u_texture;
            uniform int u_vizMode;

            varying vec2 v_texCoord;

            vec3 cellularColor(float b) {
                // Biological cell coloring: purple cytoplasm to pink nucleus
                vec3 background = vec3(0.04, 0.03, 0.06);
                vec3 cytoplasm = vec3(0.25, 0.15, 0.35);
                vec3 membrane = vec3(0.6, 0.3, 0.5);
                vec3 nucleus = vec3(0.95, 0.5, 0.7);

                if (b < 0.15) {
                    return mix(background, cytoplasm, b / 0.15);
                } else if (b < 0.4) {
                    return mix(cytoplasm, membrane, (b - 0.15) / 0.25);
                } else if (b < 0.7) {
                    return mix(membrane, nucleus, (b - 0.4) / 0.3);
                } else {
                    return mix(nucleus, vec3(1.0, 0.8, 0.9), (b - 0.7) / 0.3);
                }
            }

            vec3 membraneColor(float b) {
                // Highlight cell membranes/edges
                vec3 dark = vec3(0.02, 0.01, 0.04);
                vec3 edge = vec3(0.8, 0.4, 0.9);
                vec3 bright = vec3(0.4, 0.2, 0.5);

                float edge_detect = abs(b - 0.5) * 2.0;
                edge_detect = 1.0 - edge_detect;
                edge_detect = pow(edge_detect, 3.0);

                vec3 base = mix(dark, bright, b);
                return mix(base, edge, edge_detect * 0.8);
            }

            vec3 xrayColor(float b) {
                // X-ray/microscope style
                float intensity = 1.0 - b;
                vec3 color = vec3(intensity);
                // Add slight blue tint
                color.b += 0.1 * b;
                return color;
            }

            void main() {
                vec4 data = texture2D(u_texture, v_texCoord);
                float b = data.g;

                vec3 color;
                if (u_vizMode == 0) {
                    color = cellularColor(b);
                } else if (u_vizMode == 1) {
                    color = membraneColor(b);
                } else {
                    color = xrayColor(b);
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        const simulationProgram = createProgram(vertexShaderSource, simulationShaderSource);
        const displayProgram = createProgram(vertexShaderSource, displayShaderSource);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        let textures = [];
        let framebuffers = [];

        function createTexture() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, simWidth, simHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }

        function setupBuffers() {
            textures.forEach(t => gl.deleteTexture(t));
            framebuffers.forEach(fb => gl.deleteFramebuffer(fb));

            textures = [createTexture(), createTexture()];
            framebuffers = textures.map(texture => {
                const fb = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                return fb;
            });

            initializeSimulation();
        }

        function initializeSimulation() {
            const data = new Uint8Array(simWidth * simHeight * 4);

            for (let y = 0; y < simHeight; y++) {
                for (let x = 0; x < simWidth; x++) {
                    const idx = (y * simWidth + x) * 4;

                    data[idx] = 255;     // A = 1.0
                    data[idx + 1] = 0;   // B = 0.0
                    data[idx + 2] = 0;
                    data[idx + 3] = 255;

                    // Create initial "cells" - scattered seed points
                    const cx = simWidth / 2;
                    const cy = simHeight / 2;

                    // Central cluster
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < 25 && Math.random() > 0.4) {
                        data[idx + 1] = 255;
                    }

                    // A few scattered cells
                    if (Math.random() < 0.0008) {
                        // Create small circular seeds
                        for (let dy = -3; dy <= 3; dy++) {
                            for (let dx = -3; dx <= 3; dx++) {
                                if (dx * dx + dy * dy <= 9) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < simWidth && ny >= 0 && ny < simHeight) {
                                        const nidx = (ny * simWidth + nx) * 4;
                                        data[nidx + 1] = 255;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            textures.forEach(texture => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, simWidth, simHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            });
        }

        let currentBuffer = 0;

        function simulate() {
            gl.useProgram(simulationProgram);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentBuffer]);
            gl.viewport(0, 0, simWidth, simHeight);

            gl.uniform1i(gl.getUniformLocation(simulationProgram, 'u_texture'), 0);
            gl.uniform2f(gl.getUniformLocation(simulationProgram, 'u_resolution'), simWidth, simHeight);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_feed'), params.feed);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_kill'), params.kill);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_da'), params.da);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_db'), params.db);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_dt'), 1.0);
            gl.uniform2f(gl.getUniformLocation(simulationProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_brushSize'), params.brushSize);
            gl.uniform1f(gl.getUniformLocation(simulationProgram, 'u_mouseDown'), mouseDown ? 1.0 : 0.0);

            const posLoc = gl.getAttribLocation(simulationProgram, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            currentBuffer = 1 - currentBuffer;
        }

        function display() {
            gl.useProgram(displayProgram);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentBuffer]);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_texture'), 0);

            let vizModeInt = 0;
            if (params.vizMode === 'membrane') vizModeInt = 1;
            else if (params.vizMode === 'xray') vizModeInt = 2;
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_vizMode'), vizModeInt);

            const posLoc = gl.getAttribLocation(displayProgram, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;

            const minDim = Math.min(window.innerWidth, window.innerHeight);
            if (minDim < 600) {
                simWidth = simHeight = 256;
            } else if (minDim < 1200) {
                simWidth = simHeight = 512;
            } else {
                simWidth = simHeight = 768;
            }

            document.getElementById('resolution').textContent = `${simWidth}x${simHeight}`;
            setupBuffers();
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = now;
                document.getElementById('fps').textContent = fps;
            }
        }

        function animate() {
            for (let i = 0; i < 10; i++) {
                simulate();
            }
            display();
            updateFPS();
            requestAnimationFrame(animate);
        }

        resize();
        window.addEventListener('resize', resize);
        animate();

        // Mouse/touch interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = 1.0 - (e.clientY - rect.top) / rect.height;
            return { x, y };
        }

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const pos = getMousePos(e);
                mouseX = pos.x;
                mouseY = pos.y;
            }
        });

        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mouseleave', () => mouseDown = false);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const touch = e.touches[0];
            const pos = getMousePos(touch);
            mouseX = pos.x;
            mouseY = pos.y;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getMousePos(touch);
            mouseX = pos.x;
            mouseY = pos.y;
        }, { passive: false });

        canvas.addEventListener('touchend', () => mouseDown = false);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const brushInput = document.getElementById('brushSize');
            let newSize = params.brushSize - Math.sign(e.deltaY) * 2;
            newSize = Math.max(5, Math.min(40, newSize));
            params.brushSize = newSize;
            brushInput.value = newSize;
            document.getElementById('brushValue').textContent = newSize;
        }, { passive: false });

        // UI Controls
        document.getElementById('feedRate').addEventListener('input', (e) => {
            params.feed = parseFloat(e.target.value);
            document.getElementById('feedValue').textContent = params.feed.toFixed(4);
            document.querySelectorAll('.phase-btn').forEach(btn => btn.classList.remove('active'));
        });

        document.getElementById('killRate').addEventListener('input', (e) => {
            params.kill = parseFloat(e.target.value);
            document.getElementById('killValue').textContent = params.kill.toFixed(4);
            document.querySelectorAll('.phase-btn').forEach(btn => btn.classList.remove('active'));
        });

        document.getElementById('diffusionA').addEventListener('input', (e) => {
            params.da = parseFloat(e.target.value);
            document.getElementById('daValue').textContent = params.da.toFixed(2);
        });

        document.getElementById('diffusionB').addEventListener('input', (e) => {
            params.db = parseFloat(e.target.value);
            document.getElementById('dbValue').textContent = params.db.toFixed(2);
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            params.brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = params.brushSize;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initializeSimulation();
        });

        // Phase buttons
        function applyPhase(phaseName) {
            const phase = phases[phaseName];
            if (!phase) return;

            params.feed = phase.feed;
            params.kill = phase.kill;
            params.da = phase.da;
            params.db = phase.db;
            params.currentPhase = phaseName;

            document.getElementById('feedRate').value = phase.feed;
            document.getElementById('feedValue').textContent = phase.feed.toFixed(4);
            document.getElementById('killRate').value = phase.kill;
            document.getElementById('killValue').textContent = phase.kill.toFixed(4);
            document.getElementById('diffusionA').value = phase.da;
            document.getElementById('daValue').textContent = phase.da.toFixed(2);
            document.getElementById('diffusionB').value = phase.db;
            document.getElementById('dbValue').textContent = phase.db.toFixed(2);

            document.querySelectorAll('.phase-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.phase === phaseName);
            });

            document.getElementById('currentPhase').textContent = phase.name;
        }

        document.querySelectorAll('.phase-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                applyPhase(btn.dataset.phase);
            });
        });

        // Visualization mode
        document.querySelectorAll('.viz-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                params.vizMode = btn.dataset.viz;
                document.querySelectorAll('.viz-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Info panel
        document.getElementById('infoBtn').addEventListener('click', () => {
            const panel = document.getElementById('infoPanel');
            panel.classList.toggle('active');
        });

        // Close info panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('infoPanel');
            const btn = document.getElementById('infoBtn');
            if (!panel.contains(e.target) && !btn.contains(e.target)) {
                panel.classList.remove('active');
            }
        });
    </script>
</body>
</html>
